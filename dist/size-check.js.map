{
  "version": 3,
  "sources": ["../src/engine/rng.ts", "../src/engine/eventBus.ts", "../src/content/registries.ts", "../src/state/serialization.ts", "../src/engine/orchestrator.ts", "../src/engine/errorBoundary.ts", "../src/engine/rng-shim.ts", "../src/engine/pool.ts", "../src/content/initialContent.ts", "../src/state/gameState.ts", "../src/systems/playerSystem.ts", "../src/systems/inputSystem.ts", "../src/systems/enemySystem.ts", "../src/systems/bulletSystem.ts", "../src/systems/collisionSystem.ts", "../src/systems/renderSystem.ts", "../src/systems/cameraSystem.ts", "../src/systems/waveSystem.ts", "../src/systems/parallaxSystem.ts", "../src/main.ts"],
  "sourcesContent": ["/**\n * Deterministic RNG wrapper (Phase 1 task P1-12).\n * Linear Congruential Generator parameters chosen for 32-bit speed & reproducibility.\n * Not cryptographically secure.\n */\nexport class RNG {\n  private state: number;\n  constructor(seed: number | string) {\n    if (typeof seed === 'string') {\n      // simple string hash (djb2)\n      let h = 5381;\n      for (let i = 0; i < seed.length; i++) {\n        h = ((h << 5) + h) ^ seed.charCodeAt(i);\n      }\n      this.state = h >>> 0;\n    } else {\n      this.state = seed >>> 0;\n    }\n    if (this.state === 0) this.state = 0x1; // avoid zero lock\n  }\n  /** Float in [0,1) */\n  next(): number {\n    // LCG (Numerical Recipes): x = (1664525*x + 1013904223) mod 2^32\n    this.state = (1664525 * this.state + 1013904223) >>> 0;\n    return this.state / 0x100000000; // 2^32\n  }\n  /** Int in [min, max] inclusive */\n  int(min: number, max: number): number {\n    if (max < min) throw new Error('RNG.int: max < min');\n    const span = max - min + 1;\n    return min + Math.floor(this.next() * span);\n  }\n  /** Pick one element deterministically */\n  choice<T>(arr: readonly T[]): T {\n    if (!arr.length) throw new Error('RNG.choice: empty array');\n    return arr[this.int(0, arr.length - 1)];\n  }\n  /** Serialize current state */\n  snapshot(): number { return this.state; }\n  /** Restore state */\n  restore(state: number): void { this.state = state >>> 0 || 0x1; }\n}\n\n// Convenience singleton for early prototyping (will be replaced by injected instances):\nexport const globalRng = new RNG('geoturret2-seed');\n", "/**\n * Lightweight event bus (Phase 1 P1-3).\n * String event names mapped to listener arrays. Minimal to keep perf predictable.\n */\nexport type EventHandler<T = unknown> = (payload: T) => void;\n\n// Core event map (extend in future phases). Add new keys here for compile-time safety.\nexport interface CoreEventMap {\n  frame: { frame: number; time: number };\n  snapshot: { frame: number; time: number; registryHash: string; summary: { kills: number; wave: number } };\n  waveStart: { wave: number; prevWave: number; target: number };\n  error: { message: string; context?: any };\n  perfSample: { frame: number; profiling: Record<string, number> };\n}\n\ntype AnyEventMap = Record<string, any>;\n\nclass EventBus<M extends AnyEventMap> {\n  private listeners: Map<keyof M & string, Set<EventHandler<any>>> = new Map();\n\n  on<K extends keyof M & string>(event: K, handler: EventHandler<M[K]>): () => void;\n  // Fallback for dynamic / future events\n  on(event: string, handler: EventHandler<any>): () => void;\n  on(event: string, handler: EventHandler<any>): () => void {\n    let set = this.listeners.get(event as any);\n    if (!set) { set = new Set(); this.listeners.set(event as any, set); }\n    set.add(handler as EventHandler);\n    return () => this.off(event, handler);\n  }\n\n  off<K extends keyof M & string>(event: K, handler: EventHandler<M[K]>): void;\n  off(event: string, handler: EventHandler<any>): void;\n  off(event: string, handler: EventHandler<any>): void {\n    const set = this.listeners.get(event as any);\n    if (set) {\n      set.delete(handler as EventHandler);\n      if (!set.size) this.listeners.delete(event as any);\n    }\n  }\n\n  emit<K extends keyof M & string>(event: K, payload: M[K]): void;\n  emit(event: string, payload: any): void;\n  emit(event: string, payload: any): void {\n    const set = this.listeners.get(event as any);\n    if (!set) return;\n    [...set].forEach(h => { try { h(payload); } catch {/* swallowed; boundary handles */} });\n  }\n\n  clear(): void { this.listeners.clear(); }\n}\n\nexport const eventBus: EventBus<CoreEventMap> = new EventBus();\n\n// Helper type exports for consumers\nexport type EventMap = CoreEventMap;\n", "/** Data registries (Phase 1 P1-5). Pure structures for deterministic content. */\nexport interface EnemyDef { id: string; hp: number; speed: number; }\nexport interface PowerupDef { id: string; duration?: number; }\nexport interface UpgradeDef { id: string; tier: number; }\nexport interface WaveModDef { id: string; description: string; }\nexport interface BossPatternDef { id: string; version: number; }\n\nconst enemies = new Map<string, EnemyDef>();\nconst powerups = new Map<string, PowerupDef>();\nconst upgrades = new Map<string, UpgradeDef>();\nconst waveMods = new Map<string, WaveModDef>();\nconst bossPatterns = new Map<string, BossPatternDef>();\n\nfunction ensureUnique<T extends { id: string }>(map: Map<string, T>, def: T, kind: string) {\n  if (map.has(def.id)) throw new Error(`${kind} already registered: ${def.id}`);\n  map.set(def.id, def);\n}\n\nexport const Registries = {\n  enemy: (def: EnemyDef) => ensureUnique(enemies, def, 'enemy'),\n  powerup: (def: PowerupDef) => ensureUnique(powerups, def, 'powerup'),\n  upgrade: (def: UpgradeDef) => ensureUnique(upgrades, def, 'upgrade'),\n  waveMod: (def: WaveModDef) => ensureUnique(waveMods, def, 'waveMod'),\n  bossPattern: (def: BossPatternDef) => ensureUnique(bossPatterns, def, 'bossPattern'),\n  snapshot: () => ({ enemies: [...enemies.keys()], powerups: [...powerups.keys()], upgrades: [...upgrades.keys()], waveMods: [...waveMods.keys()], bossPatterns: [...bossPatterns.keys()] }),\n  /** Stable hash of registry composition (IDs only). Simple djb2 over sorted concatenated keys. */\n  hash(): string {\n    const collect = (m: Map<string, any>) => [...m.keys()].sort().join('|');\n    const combined = [collect(enemies), collect(powerups), collect(upgrades), collect(waveMods), collect(bossPatterns)].join('#');\n    let h = 5381;\n    for (let i=0;i<combined.length;i++) h = ((h << 5) + h) ^ combined.charCodeAt(i);\n    // Represent as 8-char hex\n    return (h >>> 0).toString(16).padStart(8,'0');\n  }\n};\n", "/** State serialization scaffold (Phase 1 P1-7). */\nimport { RNG } from '../engine';\nimport { GameState } from './gameState';\nimport { Registries } from '../content/registries';\n\nexport interface RunSnapshotMeta {\n  version: 3; // bumped (v3 adds optional parallaxLayers to summary)\n  frame: number;\n  time: number;\n  rngState: number;\n  registries: ReturnType<typeof Registries.snapshot>;\n  registryHash: string;\n  summary: { kills: number; wave: number; parallaxLayers?: { depth: number; color?: string; tileSize?: number; step?: number }[] };\n}\n\n/**\n * Create a deterministic run snapshot including RNG state, registry integrity hash and a lightweight\n * run summary (kills, wave). Wave remains a placeholder until wave progression system lands.\n */\nexport function createSnapshot(meta: { frame: number; time: number; rng: RNG; state?: Pick<GameState,'kills'|'wave'> & { parallaxLayers?: { depth: number; color?: string; tileSize?: number; step?: number }[] } }): RunSnapshotMeta {\n  const rngState = (meta.rng as any).snapshot ? (meta.rng as any).snapshot() : 0;\n  const kills = meta.state?.kills ?? 0;\n  const wave = meta.state?.wave ?? 0;\n  const parallaxLayers = meta.state?.parallaxLayers;\n  return {\n    version: 3,\n    frame: meta.frame,\n    time: meta.time,\n    rngState,\n    registries: Registries.snapshot(),\n    registryHash: Registries.hash(),\n    summary: { kills, wave, parallaxLayers }\n  };\n}\n", "/**\n * GameOrchestrator (Phase 1) \u2013 central lifecycle coordinator.\n * Fixed-step accumulator model to ensure deterministic updates across devices.\n * Rendering layer will hook in later; currently only logical systems update.\n */\nimport { eventBus } from './eventBus';\nimport { RNG } from './rng';\nimport { createSnapshot, RunSnapshotMeta } from '../state/serialization';\nimport type { GameState } from '../state/gameState';\n\nexport interface OrchestratorContext {\n  readonly frame: number;\n  readonly time: number; // accumulated simulated seconds\n  readonly rng: RNG;\n  emit: typeof eventBus.emit;\n  on: typeof eventBus.on;\n}\n\nexport interface System {\n  id: string;\n  /** Lower order runs earlier; default 0. Tie -> insertion order */\n  order?: number;\n  init?(ctx: OrchestratorContext): void;\n  update(dt: number, ctx: OrchestratorContext): void;\n  teardown?(ctx: OrchestratorContext): void;\n}\n\nexport interface OrchestratorMetrics {\n  frame: number;\n  time: number;\n  systems: number;\n  stepsLastAdvance: number;\n  accumulator: number;\n  profiling?: Record<string, number>; // ms per system last frame\n}\n\nexport class GameOrchestrator {\n  private systems: System[] = [];\n  private frame = 0;\n  private time = 0; // simulated seconds\n  private accumulator = 0;\n  private readonly step: number;\n  private readonly rng: RNG;\n  private profilerEnabled = false;\n  private lastProfile: Record<string, number> | undefined;\n  private summarySource?: () => Pick<GameState,'kills'|'wave'>;\n\n  constructor(opts?: { fixedStep?: number; seed?: number | string | RNG; summarySource?: () => Pick<GameState,'kills'|'wave'> }) {\n    this.step = opts?.fixedStep ?? (1 / 60);\n  if (opts?.seed instanceof RNG) this.rng = opts.seed;\n  else if (typeof opts?.seed !== 'undefined') this.rng = new RNG(opts.seed as any);\n  else throw new Error('Orchestrator requires explicit seed (number|string|RNG) for determinism.');\n  this.summarySource = opts?.summarySource;\n  }\n\n  register(system: System): void {\n    if (this.systems.find(s => s.id === system.id)) throw new Error(`System id already registered: ${system.id}`);\n    this.systems.push(system);\n    this.sortSystems();\n  }\n\n  private sortSystems() {\n    this.systems.sort((a, b) => (a.order ?? 0) - (b.order ?? 0));\n  }\n\n  init(): void {\n    const ctx = this.buildContext();\n    for (const s of this.systems) s.init?.(ctx);\n  }\n\n  /**\n   * Advance simulation by elapsed real seconds (can be fractional). Returns number of fixed steps processed.\n   */\n  advance(elapsed: number): number {\n    this.accumulator += elapsed;\n    let steps = 0;\n    while (this.accumulator + 1e-12 >= this.step) { // tiny epsilon to mitigate float drift\n      this.accumulator -= this.step;\n      this.tick();\n      steps++;\n    }\n    return steps;\n  }\n\n  private tick() {\n    const ctx = this.buildContext();\n    if (this.profilerEnabled) {\n      this.lastProfile = {};\n      for (const s of this.systems) {\n        const start = performance.now();\n        s.update(this.step, ctx);\n        this.lastProfile[s.id] = performance.now() - start;\n      }\n  eventBus.emit('perfSample', { frame: this.frame, profiling: this.lastProfile });\n    } else {\n      for (const s of this.systems) s.update(this.step, ctx);\n    }\n    this.frame++;\n    this.time += this.step;\n    eventBus.emit('frame', { frame: this.frame, time: this.time });\n  }\n\n  private buildContext(): OrchestratorContext {\n    return {\n      frame: this.frame,\n      time: this.time,\n      rng: this.rng,\n      emit: eventBus.emit.bind(eventBus),\n      on: eventBus.on.bind(eventBus)\n    };\n  }\n\n  teardown(): void {\n    const ctx = this.buildContext();\n    for (const s of [...this.systems].reverse()) s.teardown?.(ctx);\n    // Note: eventBus cleared externally when resetting environment.\n  }\n\n  getMetrics(): OrchestratorMetrics {\n    return { frame: this.frame, time: this.time, systems: this.systems.length, stepsLastAdvance: 0, accumulator: this.accumulator, profiling: this.lastProfile };\n  }\n\n  getStep(): number { return this.step; }\n\n  enableProfiler(flag = true): void { this.profilerEnabled = flag; }\n\n  /** Export a deterministic run snapshot (frame/time/RNG + registries). */\n  snapshot(): RunSnapshotMeta {\n  const snap = createSnapshot({ frame: this.frame, time: this.time, rng: this.rng, state: this.summarySource?.() });\n  eventBus.emit('snapshot', { frame: snap.frame, time: snap.time, registryHash: snap.registryHash, summary: snap.summary });\n  return snap;\n  }\n}\n", "/** Error boundary ring buffer (Phase 1 P1-13). */\nexport interface CapturedError { time: number; message: string; stack?: string; }\n\nclass ErrorRingBuffer {\n  private buf: CapturedError[] = [];\n  constructor(private capacity = 50) {}\n  push(err: unknown) {\n    const e = err instanceof Error ? err : new Error(String(err));\n    this.buf.push({ time: Date.now(), message: e.message, stack: e.stack });\n    if (this.buf.length > this.capacity) this.buf.shift();\n  }\n  list(): CapturedError[] { return [...this.buf]; }\n  clear() { this.buf = []; }\n}\n\nexport const errorBuffer = new ErrorRingBuffer();\n\nexport function safe<T>(fn: () => T, fallback?: T): T | undefined {\n  try { return fn(); } catch (e) { errorBuffer.push(e); return fallback; }\n}\n", "/** RNG shim (Phase 1 P1-14) \u2013 temporary wrapper for legacy Math.random sites. */\nimport { globalRng } from './rng';\n// Only apply once per session; caller opt-in.\nexport function installRngShim() {\n  if ((Math as any)._gt2ShimInstalled) return;\n  const original = Math.random;\n  (Math as any)._originalRandom = original;\n  Math.random = () => globalRng.next();\n  (Math as any)._gt2ShimInstalled = true;\n}\n", "/**\n * Generic object pool (Phase 1 P1-4 scaffold) for transient entities: particles, projectiles, etc.\n * Lightweight: no dependency on specific object shape \u2013 factory + reset callbacks provided.\n */\nexport interface PoolStats { size: number; free: number; inUse: number; created: number; max?: number }\n\nexport interface PoolOptions<T> {\n  /** Initial capacity to preallocate. */\n  initial: number;\n  /** Optional hard max capacity \u2013 further acquire beyond growth returns undefined. */\n  max?: number;\n  /** Factory to create a new instance when expanding. */\n  create: () => T;\n  /** Reset invoked on release before returning to free list. */\n  reset?: (obj: T) => void;\n}\n\nexport class Pool<T> {\n  private free: T[] = [];\n  private total = 0;\n  private created = 0;\n  private readonly max?: number;\n  constructor(private opts: PoolOptions<T>) {\n    this.max = opts.max;\n    for (let i = 0; i < opts.initial; i++) this.free.push(this.make());\n  }\n  private make(): T { this.total++; this.created++; return this.opts.create(); }\n  acquire(): T | undefined {\n    if (this.free.length) return this.free.pop()!;\n    if (this.max !== undefined && this.total >= this.max) return undefined;\n    return this.make();\n  }\n  release(obj: T): void {\n    this.opts.reset?.(obj);\n    this.free.push(obj);\n  }\n  stats(): PoolStats { return { size: this.total, free: this.free.length, inUse: this.total - this.free.length, created: this.created, max: this.max }; }\n  preallocate(n: number): void {\n    for (let i = 0; i < n; i++) {\n      if (this.max !== undefined && this.total >= this.max) break;\n      this.free.push(this.make());\n    }\n  }\n}\n", "/**\n * Initial placeholder content definitions (Phase 1 seed data).\n * Replace / expand during Feature Parity implementation.\n */\nimport { Registries } from './registries';\n\n// Enemies (baseline archetypes)\nRegistries.enemy({ id: 'grunt', hp: 10, speed: 1.0 });\nRegistries.enemy({ id: 'swift', hp: 6, speed: 1.6 });\nRegistries.enemy({ id: 'tank', hp: 30, speed: 0.6 });\n\n// Powerups\nRegistries.powerup({ id: 'shield', duration: 5 });\nRegistries.powerup({ id: 'overdrive', duration: 8 });\n\n// Upgrades\nRegistries.upgrade({ id: 'damage+', tier: 1 });\nRegistries.upgrade({ id: 'firerate+', tier: 1 });\nRegistries.upgrade({ id: 'spread+', tier: 1 });\n\n// Wave Modifiers\nRegistries.waveMod({ id: 'storm', description: 'Increased projectile density' });\nRegistries.waveMod({ id: 'gravity', description: 'Projectiles arc downward' });\n\n// Boss Patterns (stub ids / versions)\nRegistries.bossPattern({ id: 'laser-cross', version: 1 });\nRegistries.bossPattern({ id: 'safe-lane-volley', version: 1 });\nRegistries.bossPattern({ id: 'multi-beam-intersect', version: 1 });\n\n// No exports: side-effect module. Import once at startup (or in tests) to populate registries.\n", "/** Minimal game state for demo run (now with pooling). */\nexport interface Enemy { id: number; x: number; y: number; vx: number; vy: number; hp: number; alive: boolean; }\nexport interface Bullet { id: number; x: number; y: number; vx: number; vy: number; alive: boolean; }\n\nimport { Pool } from '../engine/pool';\n\nexport interface GameState {\n  enemies: Enemy[];\n  bullets: Bullet[];\n  enemyPool: Pool<Enemy>;\n  bulletPool: Pool<Bullet>;\n  kills: number;\n  /** Current wave index (placeholder until wave system implemented). */\n  wave: number;\n  /** Kills accumulated within current wave. */\n  waveKills: number;\n  /** Target kills needed to advance to next wave. */\n  waveTarget: number;\n  enemySpawnTimer: number;\n  bulletTimer: number;\n  nextEnemyId: number;\n  nextBulletId: number;\n  /** Camera data (world space + fx). */\n  camera: { x: number; y: number; zoom: number; targetZoom: number; shakeRemaining: number; shakeDuration: number; shakeAmp: number; shakeFreq: number; shakeX: number; shakeY: number };\n  /** Parallax layer offsets computed last frame (for render systems wanting cached values). */\n  parallax?: { layers: { depth: number; offsetX: number; offsetY: number }[] };\n}\n\nexport function createGameState(): GameState {\n  const enemyPool = new Pool<Enemy>({\n    initial: 32,\n    create: () => ({ id: 0, x: 0, y: 0, vx: 0, vy: 0, hp: 0, alive: false }),\n    reset: e => { e.alive = false; }\n  });\n  const bulletPool = new Pool<Bullet>({\n    initial: 64,\n    create: () => ({ id: 0, x: 0, y: 0, vx: 0, vy: 0, alive: false }),\n    reset: b => { b.alive = false; }\n  });\n  return { enemies: [], bullets: [], enemyPool, bulletPool, kills: 0, wave: 0, waveKills: 0, waveTarget: 10, enemySpawnTimer: 0, bulletTimer: 0, nextEnemyId: 1, nextBulletId: 1, camera: { x: 0, y: 0, zoom: 1, targetZoom: 1, shakeRemaining: 0, shakeDuration: 0, shakeAmp: 0, shakeFreq: 25, shakeX: 0, shakeY: 0 }, parallax: { layers: [] } };\n}\n", "import { System, OrchestratorContext } from '../engine';\nimport { GameState } from '../state/gameState';\n\nexport interface Player { x: number; y: number; }\nexport const player: Player = { x: 0, y: 0 };\n\nexport function createPlayerSystem(state: GameState): System {\n  return {\n    id: 'player', order: -100,\n    init: () => {\n      player.x = 0; player.y = 0;\n    },\n    update: (_dt, _ctx: OrchestratorContext) => {\n      // For now player fixed at center (0,0) \u2013 coordinates are relative; render system will translate.\n    }\n  };\n}\n", "import { System, OrchestratorContext } from '../engine';\nimport { player } from './playerSystem';\n\ninterface KeyState { [code: string]: boolean }\n\nexport function createInputSystem(speed = 120): System {\n  const keys: KeyState = {};\n  function onDown(e: KeyboardEvent) { keys[e.key.toLowerCase()] = true; }\n  function onUp(e: KeyboardEvent) { keys[e.key.toLowerCase()] = false; }\n  return {\n    id: 'input', order: -200, // before player logic\n    init: () => {\n      window.addEventListener('keydown', onDown);\n      window.addEventListener('keyup', onUp);\n    },\n    update: (dt: number, _ctx: OrchestratorContext) => {\n      let vx = 0, vy = 0;\n      if (keys['w'] || keys['arrowup']) vy -= 1;\n      if (keys['s'] || keys['arrowdown']) vy += 1;\n      if (keys['a'] || keys['arrowleft']) vx -= 1;\n      if (keys['d'] || keys['arrowright']) vx += 1;\n      if (vx || vy) {\n        const len = Math.hypot(vx, vy) || 1;\n        vx /= len; vy /= len;\n        player.x += vx * speed * dt;\n        player.y += vy * speed * dt;\n      }\n    },\n    teardown: () => {\n      window.removeEventListener('keydown', onDown);\n      window.removeEventListener('keyup', onUp);\n    }\n  };\n}\n", "import { System, OrchestratorContext } from '../engine';\nimport { GameState, Enemy } from '../state/gameState';\n\nexport function createEnemySystem(state: GameState): System {\n  return {\n    id: 'enemySpawn', order: -50,\n    update: (dt, ctx: OrchestratorContext) => {\n      state.enemySpawnTimer += dt;\n      // spawn every 0.75s\n      const interval = 0.75;\n      while (state.enemySpawnTimer >= interval) {\n        state.enemySpawnTimer -= interval;\n        const slot = state.enemyPool.acquire();\n        if (!slot) break; // pool exhausted (future: metrics / backpressure)\n        const angle = ctx.rng.next() * Math.PI * 2;\n        const dist = 120 + ctx.rng.next() * 60; // spawn ring\n        const speed = 20 + ctx.rng.next() * 20; // units per second\n        slot.id = state.nextEnemyId++;\n        slot.x = Math.cos(angle) * dist;\n        slot.y = Math.sin(angle) * dist;\n        slot.vx = -Math.cos(angle) * speed; // head roughly toward center\n        slot.vy = -Math.sin(angle) * speed;\n        slot.hp = 1;\n        slot.alive = true;\n        state.enemies.push(slot as Enemy);\n      }\n      // move enemies (in-place; dead entries retained until cleanup pass)\n      for (const e of state.enemies) if (e.alive) { e.x += e.vx * dt; e.y += e.vy * dt; }\n    }\n  };\n}\n", "import { System, OrchestratorContext } from '../engine';\nimport { GameState, Bullet } from '../state/gameState';\nimport { player } from './playerSystem';\n\nexport function createBulletSystem(state: GameState): System {\n  return {\n    id: 'bullets', order: 0,\n    update: (dt, _ctx: OrchestratorContext) => {\n      state.bulletTimer += dt;\n      const fireInterval = 0.2; // 5 shots per second\n      while (state.bulletTimer >= fireInterval) {\n        state.bulletTimer -= fireInterval;\n        const slot = state.bulletPool.acquire();\n        if (!slot) break; // pool exhausted (rare for demo)\n        const idx = state.nextBulletId;\n        const angle = (idx % 60) * (Math.PI * 2 / 60);\n        const speed = 140;\n        slot.id = state.nextBulletId++;\n        slot.x = player.x; slot.y = player.y;\n        slot.vx = Math.cos(angle) * speed; slot.vy = Math.sin(angle) * speed;\n        slot.alive = true;\n        state.bullets.push(slot as Bullet);\n      }\n      // integrate bullets\n      for (const b of state.bullets) if (b.alive) { b.x += b.vx * dt; b.y += b.vy * dt; }\n    }\n  };\n}\n", "import { System, OrchestratorContext } from '../engine';\nimport { GameState } from '../state/gameState';\n\nexport function createCollisionSystem(state: GameState): System {\n  return {\n    id: 'collision', order: 10,\n    update: (_dt, _ctx: OrchestratorContext) => {\n      for (const b of state.bullets) if (b.alive) {\n        for (const e of state.enemies) if (e.alive) {\n          const dx = e.x - b.x; const dy = e.y - b.y;\n          if (dx*dx + dy*dy < 12*12) { // hit radius 12\n            e.alive = false; b.alive = false; state.kills++; state.waveKills++; break;\n          }\n        }\n      }\n      // periodic cleanup: reclaim dead or out-of-bounds (every 20 frames roughly via kills heuristic)\n      if (state.kills % 5 === 0) {\n        for (let i = state.enemies.length - 1; i >= 0; i--) {\n          const e = state.enemies[i];\n          if (!e.alive) { state.enemies.splice(i,1); state.enemyPool.release(e); }\n        }\n        for (let i = state.bullets.length - 1; i >= 0; i--) {\n          const b = state.bullets[i];\n            if (!b.alive || Math.abs(b.x) > 400 || Math.abs(b.y) > 400) { state.bullets.splice(i,1); state.bulletPool.release(b); }\n        }\n      }\n    }\n  };\n}\n", "import { System, OrchestratorContext } from '../engine';\nimport { GameState } from '../state/gameState';\nimport { player } from './playerSystem';\n\n// Single definitive render system (previous duplicate implementations merged).\nexport function createRenderSystem(state: GameState): System {\n  let canvas: HTMLCanvasElement | null = null;\n  let ctx: CanvasRenderingContext2D | null = null;\n  function init() {\n    canvas = document.getElementById('game') as HTMLCanvasElement | null;\n    if (!canvas) return; ctx = canvas.getContext('2d');\n  }\n  function clear() {\n    if (!canvas || !ctx) return;\n    ctx.fillStyle = '#000';\n    ctx.fillRect(0,0,canvas.width,canvas.height);\n  }\n  function translateOrigin() {\n    if (!canvas || !ctx) return;\n    ctx.save();\n    const baseX = canvas.width/(2*devicePixelRatio);\n    const baseY = canvas.height/(2*devicePixelRatio);\n    ctx.translate(baseX, baseY);\n    // Camera zoom\n    const z = state.camera.zoom || 1;\n    ctx.scale(z, z);\n    // Apply camera offset + shake\n    ctx.translate(-state.camera.x + (state.camera.shakeX||0)/z, -state.camera.y + (state.camera.shakeY||0)/z);\n  }\n  function restore() { if (ctx) ctx.restore(); }\n  return {\n    id: 'render', order: 100,\n    init: () => { if (typeof window !== 'undefined') init(); },\n    update: () => {\n      if (!canvas || !ctx) return;\n      clear();\n      translateOrigin();\n      // Parallax background: use cached layers from parallax system (fallback to static if absent)\n      const renderLayers = state.parallax?.layers?.length ? state.parallax!.layers : [\n        { depth: 0.2, offsetX: state.camera.x * 0.2, offsetY: state.camera.y * 0.2 },\n        { depth: 0.5, offsetX: state.camera.x * 0.5, offsetY: state.camera.y * 0.5 },\n      ];\n      for (const l of renderLayers) {\n        const parX = (l as any).offsetX;\n        const parY = (l as any).offsetY;\n        const color = (l as any).color || (l.depth < 0.3 ? '#113' : '#225');\n        ctx.fillStyle = color;\n        const size = (l as any).tileSize || (l.depth < 0.3 ? 1800 : 1200);\n        const step = (l as any).step || (l.depth < 0.3 ? 140 : 90);\n        const startX = Math.floor((parX - size/2)/step)*step;\n        const startY = Math.floor((parY - size/2)/step)*step;\n        for (let x = startX; x < parX + size/2; x += step) {\n          for (let y = startY; y < parY + size/2; y += step) {\n            const sx = x - parX;\n            const sy = y - parY;\n            ctx.fillRect(sx, sy, 2,2);\n          }\n        }\n      }\n      // Player\n      ctx.strokeStyle = '#0af';\n      ctx.beginPath(); ctx.arc(player.x, player.y, 10, 0, Math.PI*2); ctx.stroke();\n      // Bullets\n      ctx.fillStyle = '#ff0';\n      for (const b of state.bullets) if (b.alive) ctx.fillRect(b.x-2, b.y-2, 4,4);\n      // Enemies\n      ctx.fillStyle = '#f44';\n      for (const e of state.enemies) if (e.alive) { ctx.beginPath(); ctx.arc(e.x, e.y, 8, 0, Math.PI*2); ctx.fill(); }\n      restore();\n    }\n  };\n}\n", "import { System, OrchestratorContext, eventBus } from '../engine';\nimport { GameState } from '../state/gameState';\nimport { player } from './playerSystem';\n\n/** Simple smooth camera following the player with configurable lag. */\nexport function createCameraSystem(state: GameState, opts?: { stiffness?: number; worldRadius?: number; bounds?: { minX: number; maxX: number; minY: number; maxY: number }; deadzone?: number; zoomStiffness?: number; leadTime?: number; maxLead?: number }): System {\n  const stiffness = opts?.stiffness ?? 10; // follow smoothing\n  const deadzone = opts?.deadzone ?? 8;\n  const zoomStiff = opts?.zoomStiffness ?? 6;\n  const leadTime = opts?.leadTime ?? 0; // seconds to look ahead along velocity\n  const maxLead = opts?.maxLead ?? 160; // clamp distance of lead\n  // Backwards compat: worldRadius if rectangular bounds not provided\n  const worldRadius = opts?.worldRadius ?? 0;\n  const rect = opts?.bounds;\n  // Expose simple shake API\n  if (typeof window !== 'undefined') {\n    (window as any).cameraShake = function(duration = 0.4, amp = 24, freq = 28) {\n      state.camera.shakeDuration = duration;\n      state.camera.shakeRemaining = duration;\n      state.camera.shakeAmp = amp;\n      state.camera.shakeFreq = freq;\n    };\n    (window as any).cameraZoomTo = function(z = 1) { state.camera.targetZoom = Math.max(0.2, Math.min(3, z)); };\n  }\n  // Track previous player position for velocity estimation\n  let prevPx = player.x;\n  let prevPy = player.y;\n  return {\n    id: 'camera', order: -150, // after input (-200) but before player (-100) not required, just early\n    update: (dt: number, _ctx: OrchestratorContext) => {\n      const cx = state.camera.x;\n      const cy = state.camera.y;\n      // target player pos\n      let tx = player.x;\n      let ty = player.y;\n      // Velocity-based lead (estimate velocity from previous frame)\n      if (leadTime > 0 && dt > 0) {\n        const vx = (player.x - prevPx) / dt;\n        const vy = (player.y - prevPy) / dt;\n        let lx = vx * leadTime;\n        let ly = vy * leadTime;\n        const mag = Math.hypot(lx, ly);\n        if (mag > maxLead) { const s = maxLead / (mag || 1); lx *= s; ly *= s; }\n        tx += lx; ty += ly;\n      }\n      // Deadzone: if player within deadzone rect around camera, don't adjust target (reduces micro jitter)\n      if (Math.abs(tx - cx) < deadzone) tx = cx;\n      if (Math.abs(ty - cy) < deadzone) ty = cy;\n      // exponential smoothing toward player\n      const lerp = 1 - Math.exp(-stiffness * dt);\n      let nx = cx + (tx - cx) * lerp;\n      let ny = cy + (ty - cy) * lerp;\n      // Clamp to bounds\n      if (rect) {\n        nx = Math.max(rect.minX, Math.min(rect.maxX, nx));\n        ny = Math.max(rect.minY, Math.min(rect.maxY, ny));\n      } else if (worldRadius > 0) {\n        const dist2 = nx*nx + ny*ny;\n        const r = worldRadius;\n        if (dist2 > r*r) { const d = Math.sqrt(dist2); nx = nx / d * r; ny = ny / d * r; }\n      }\n      state.camera.x = nx;\n      state.camera.y = ny;\n      // Zoom smoothing toward targetZoom\n      const zoomLerp = 1 - Math.exp(-zoomStiff * dt);\n      state.camera.zoom += (state.camera.targetZoom - state.camera.zoom) * zoomLerp;\n      // Shake update\n      if (state.camera.shakeRemaining > 0) {\n        state.camera.shakeRemaining -= dt;\n        const t = state.camera.shakeDuration - state.camera.shakeRemaining;\n        const progress = Math.max(0, state.camera.shakeRemaining) / state.camera.shakeDuration;\n        const damp = progress; // linear falloff\n        const f = state.camera.shakeFreq;\n        // Use simple sin noise based on time & remaining\n        state.camera.shakeX = (Math.sin(t * f * 13.37) * 0.5 + Math.sin(t * f * 7.11) * 0.5) * state.camera.shakeAmp * damp;\n        state.camera.shakeY = (Math.cos(t * f * 11.17) * 0.5 + Math.sin(t * f * 5.27) * 0.5) * state.camera.shakeAmp * damp;\n      } else {\n        state.camera.shakeX = 0; state.camera.shakeY = 0;\n      }\n  prevPx = player.x;\n  prevPy = player.y;\n    }\n  };\n}\n", "import { System, OrchestratorContext, eventBus } from '../engine';\nimport { GameState } from '../state/gameState';\n\n/**\n * Basic wave progression system.\n * Advances wave when state.waveKills >= state.waveTarget.\n * On advance: wave++, waveKills reset, waveTarget scales (ceil(target * 1.25)).\n * Emits 'waveStart' typed event.\n */\nexport function createWaveSystem(state: GameState): System {\n  return {\n    id: 'wave', order: -90, // after player, before spawners\n    update: (_dt, _ctx: OrchestratorContext) => {\n      if (state.waveKills >= state.waveTarget) {\n        const prev = state.wave;\n        state.wave += 1;\n        state.waveKills = 0;\n        // scale target modestly, cap for early phases\n        state.waveTarget = Math.min(100, Math.ceil(state.waveTarget * 1.25));\n        eventBus.emit('waveStart', { wave: state.wave, prevWave: prev, target: state.waveTarget });\n      }\n    }\n  };\n}\n", "import { System, OrchestratorContext } from '../engine';\nimport { GameState } from '../state/gameState';\n\nexport interface ParallaxLayerConfig { depth: number; density?: number; color?: string; tileSize?: number; step?: number; }\n\n/**\n * Dedicated parallax system. Computes per-layer offsets from camera and caches\n * lightweight data in state.parallax.layers for render consumption. Pure data; no DOM.\n */\nexport function createParallaxSystem(state: GameState, layers?: ParallaxLayerConfig[]): System {\n  let layerDefs: ParallaxLayerConfig[] = layers?.length ? layers : [\n    { depth: 0.2, density: 0.5, color: '#113', tileSize: 1800, step: 140 },\n    { depth: 0.5, density: 0.8, color: '#225', tileSize: 1200, step: 90 },\n  ];\n  if (typeof window !== 'undefined') {\n    const validate = (d: any): d is ParallaxLayerConfig => {\n      return d && typeof d.depth === 'number' && isFinite(d.depth) && d.depth > 0 && d.depth <= 2;\n    };\n    const sanitize = (d: any): ParallaxLayerConfig => ({\n      depth: Math.max(0.01, Math.min(2, +d.depth)),\n      density: typeof d.density === 'number' ? Math.max(0, Math.min(5, d.density)) : undefined,\n      color: typeof d.color === 'string' ? d.color : undefined,\n      tileSize: typeof d.tileSize === 'number' && d.tileSize > 0 ? Math.min(8192, d.tileSize) : undefined,\n      step: typeof d.step === 'number' && d.step > 0 ? Math.min(1024, d.step) : undefined\n    });\n    const persist = () => {\n      try {\n        const encoded = encodeURIComponent(JSON.stringify(layerDefs));\n        // Update URL param without adding history entry\n        if (typeof history !== 'undefined') {\n          const url = new URL(window.location.href);\n            url.searchParams.set('parallaxJ', encoded);\n            history.replaceState(null, '', url.toString());\n        }\n        // LocalStorage backup\n        window.localStorage.setItem('parallaxLayers', JSON.stringify(layerDefs));\n      } catch {}\n    };\n    (window as any).parallaxSetLayers = (defs: ParallaxLayerConfig[]) => {\n      if (Array.isArray(defs) && defs.every(validate)) { layerDefs = defs.map(sanitize); persist(); }\n    };\n    (window as any).parallaxAddLayer = (def: ParallaxLayerConfig) => {\n      if (validate(def)) { layerDefs.push(sanitize(def)); persist(); return true; } return false;\n    };\n    (window as any).parallaxRemoveLayer = (index: number) => {\n      if (typeof index === 'number' && index >=0 && index < layerDefs.length) { layerDefs.splice(index,1); persist(); return true; } return false;\n    };\n    (window as any).parallaxUpdateLayer = (index: number, patch: Partial<ParallaxLayerConfig>) => {\n      if (index < 0 || index >= layerDefs.length) return false;\n      const merged = { ...layerDefs[index], ...patch };\n      if (validate(merged)) { layerDefs[index] = sanitize(merged); persist(); return true; }\n      return false;\n    };\n    (window as any).parallaxListLayers = () => layerDefs.map(l => ({ ...l }));\n    (window as any).parallaxSerializeLayers = () => encodeURIComponent(JSON.stringify(layerDefs));\n    (window as any).parallaxPersist = persist;\n    // URL param (?parallaxJ=<url-encoded JSON array>) persistence\n    try {\n      const url = new URL(window.location.href);\n      const raw = url.searchParams.get('parallaxJ');\n      if (raw) {\n        const parsed = JSON.parse(decodeURIComponent(raw));\n        if (Array.isArray(parsed) && parsed.every(validate)) {\n          layerDefs = parsed.map(sanitize);\n          // Optionally write back canonical form (skip to avoid history pollution)\n        }\n      } else {\n        // Fallback to localStorage\n        const stored = window.localStorage.getItem('parallaxLayers');\n        if (stored) {\n          const parsed = JSON.parse(stored);\n          if (Array.isArray(parsed) && parsed.every(validate)) layerDefs = parsed.map(sanitize);\n        }\n      }\n    } catch (e) {\n      console.warn('[parallax] failed to parse parallaxJ param', e);\n    }\n  }\n  // Ensure state.parallax exists\n  if (!state.parallax) state.parallax = { layers: [] };\n  return {\n    id: 'parallax', order: 80, // before render (100)\n    update: (_dt: number, _ctx: OrchestratorContext) => {\n      state.parallax!.layers = layerDefs.map(ld => ({ depth: ld.depth, offsetX: state.camera.x * ld.depth, offsetY: state.camera.y * ld.depth, color: ld.color, tileSize: ld.tileSize, step: ld.step }));\n    }\n  };\n}\n", "import { GameOrchestrator, installRngShim } from './engine';\nimport './content/initialContent';\nimport { createGameState } from './state/gameState';\nimport { createPlayerSystem } from './systems/playerSystem';\nimport { createInputSystem } from './systems/inputSystem';\nimport { createEnemySystem } from './systems/enemySystem';\nimport { createBulletSystem } from './systems/bulletSystem';\nimport { createCollisionSystem } from './systems/collisionSystem';\nimport { createRenderSystem } from './systems/renderSystem';\nimport { createCameraSystem } from './systems/cameraSystem';\nimport { createWaveSystem } from './systems/waveSystem';\nimport { createParallaxSystem } from './systems/parallaxSystem';\n\n// Optional shim (will be removed once all legacy randomness replaced)\ninstallRngShim();\n\n// Seed via URL (?seed=foo) default static.\nconst url = new URL(window.location.href);\nconst seed = url.searchParams.get('seed') || 'dev-seed';\nconst autoPause = url.searchParams.get('autopause') === '1';\n\nconst gameState = createGameState();\nconst orchestrator = new GameOrchestrator({ seed, fixedStep: 1/60, summarySource: () => ({\n  kills: gameState.kills,\n  wave: gameState.wave,\n  parallaxLayers: gameState.parallax?.layers?.map(l => {\n    const ext = l as any; // extended metadata added by parallax system\n    return { depth: ext.depth, color: ext.color, tileSize: ext.tileSize, step: ext.step };\n  }) || []\n}) });\norchestrator.register(createInputSystem());\norchestrator.register(createCameraSystem(gameState));\norchestrator.register(createPlayerSystem(gameState));\norchestrator.register(createWaveSystem(gameState));\norchestrator.register(createEnemySystem(gameState));\norchestrator.register(createBulletSystem(gameState));\norchestrator.register(createCollisionSystem(gameState));\norchestrator.register(createRenderSystem(gameState));\n// Ensure parallax registered before render (order 80 vs 100)\norchestrator.register(createParallaxSystem(gameState));\n\n// Debug overlay (frame/time + optional profiling)\nconst overlay = document.getElementById('overlay')!;\nlet profiler = false;\nlet paused = false;\nlet stepOnce = false;\nwindow.addEventListener('keydown', e => {\n  if (e.key === 'p') { profiler = !profiler; orchestrator.enableProfiler(profiler); }\n  if (e.key === 's') { console.log('Snapshot', orchestrator.snapshot()); }\n  if (e.key === ' ') { paused = !paused; }\n  if (e.key === '.') { stepOnce = true; }\n});\n\norchestrator.init();\n\nlet last = performance.now();\nfunction loop(now: number) {\n  const elapsed = (now - last) / 1000;\n  last = now;\n  if (!paused) orchestrator.advance(elapsed);\n  else if (stepOnce) { orchestrator.advance(orchestrator.getStep()); stepOnce = false; }\n  const metrics = orchestrator.getMetrics();\n  overlay.textContent = `seed:${seed}\\nframe:${metrics.frame}\\ntime:${metrics.time.toFixed(2)}s\\n(kills:${gameState.kills} wave:${gameState.wave})${paused ? ' [PAUSED]' : ''}\\nE pool: inUse=${gameState.enemyPool.stats().inUse} free=${gameState.enemyPool.stats().free}\\nB pool: inUse=${gameState.bulletPool.stats().inUse} free=${gameState.bulletPool.stats().free}` + (profiler && metrics.profiling ? '\\n' + Object.entries(metrics.profiling).map(([k,v])=>`${k}:${v.toFixed(3)}ms`).join('\\n') : '');\n  requestAnimationFrame(loop);\n}\nrequestAnimationFrame(loop);\n\nconsole.log('[Geoturret2] Dev harness started with seed', seed, autoPause ? '(paused)' : '');\n"],
  "mappings": "AAKO,IAAMA,EAAN,KAAU,CACP,MACR,YAAYC,EAAuB,CACjC,GAAI,OAAOA,GAAS,SAAU,CAE5B,IAAIC,EAAI,KACR,QAASC,EAAI,EAAGA,EAAIF,EAAK,OAAQE,IAC/BD,GAAMA,GAAK,GAAKA,EAAKD,EAAK,WAAWE,CAAC,EAExC,KAAK,MAAQD,IAAM,CACrB,MACE,KAAK,MAAQD,IAAS,EAEpB,KAAK,QAAU,IAAG,KAAK,MAAQ,EACrC,CAEA,MAAe,CAEb,YAAK,MAAS,QAAU,KAAK,MAAQ,aAAgB,EAC9C,KAAK,MAAQ,UACtB,CAEA,IAAIG,EAAaC,EAAqB,CACpC,GAAIA,EAAMD,EAAK,MAAM,IAAI,MAAM,oBAAoB,EACnD,IAAME,EAAOD,EAAMD,EAAM,EACzB,OAAOA,EAAM,KAAK,MAAM,KAAK,KAAK,EAAIE,CAAI,CAC5C,CAEA,OAAUC,EAAsB,CAC9B,GAAI,CAACA,EAAI,OAAQ,MAAM,IAAI,MAAM,yBAAyB,EAC1D,OAAOA,EAAI,KAAK,IAAI,EAAGA,EAAI,OAAS,CAAC,CAAC,CACxC,CAEA,UAAmB,CAAE,OAAO,KAAK,KAAO,CAExC,QAAQC,EAAqB,CAAE,KAAK,MAAQA,IAAU,GAAK,CAAK,CAClE,EAGaC,EAAY,IAAIT,EAAI,iBAAiB,EC3BlD,IAAMU,EAAN,KAAsC,CAC5B,UAA2D,IAAI,IAKvE,GAAGC,EAAeC,EAAwC,CACxD,IAAIC,EAAM,KAAK,UAAU,IAAIF,CAAY,EACzC,OAAKE,IAAOA,EAAM,IAAI,IAAO,KAAK,UAAU,IAAIF,EAAcE,CAAG,GACjEA,EAAI,IAAID,CAAuB,EACxB,IAAM,KAAK,IAAID,EAAOC,CAAO,CACtC,CAIA,IAAID,EAAeC,EAAkC,CACnD,IAAMC,EAAM,KAAK,UAAU,IAAIF,CAAY,EACvCE,IACFA,EAAI,OAAOD,CAAuB,EAC7BC,EAAI,MAAM,KAAK,UAAU,OAAOF,CAAY,EAErD,CAIA,KAAKA,EAAeG,EAAoB,CACtC,IAAMD,EAAM,KAAK,UAAU,IAAIF,CAAY,EACtCE,GACL,CAAC,GAAGA,CAAG,EAAE,QAAQE,GAAK,CAAE,GAAI,CAAEA,EAAED,CAAO,CAAG,MAAQ,CAAkC,CAAE,CAAC,CACzF,CAEA,OAAc,CAAE,KAAK,UAAU,MAAM,CAAG,CAC1C,EAEaE,EAAmC,IAAIN,EC5CpD,IAAMO,EAAU,IAAI,IACdC,EAAW,IAAI,IACfC,EAAW,IAAI,IACfC,EAAW,IAAI,IACfC,EAAe,IAAI,IAEzB,SAASC,EAAuCC,EAAqBC,EAAQC,EAAc,CACzF,GAAIF,EAAI,IAAIC,EAAI,EAAE,EAAG,MAAM,IAAI,MAAM,GAAGC,CAAI,wBAAwBD,EAAI,EAAE,EAAE,EAC5ED,EAAI,IAAIC,EAAI,GAAIA,CAAG,CACrB,CAEO,IAAME,EAAa,CACxB,MAAQF,GAAkBF,EAAaL,EAASO,EAAK,OAAO,EAC5D,QAAUA,GAAoBF,EAAaJ,EAAUM,EAAK,SAAS,EACnE,QAAUA,GAAoBF,EAAaH,EAAUK,EAAK,SAAS,EACnE,QAAUA,GAAoBF,EAAaF,EAAUI,EAAK,SAAS,EACnE,YAAcA,GAAwBF,EAAaD,EAAcG,EAAK,aAAa,EACnF,SAAU,KAAO,CAAE,QAAS,CAAC,GAAGP,EAAQ,KAAK,CAAC,EAAG,SAAU,CAAC,GAAGC,EAAS,KAAK,CAAC,EAAG,SAAU,CAAC,GAAGC,EAAS,KAAK,CAAC,EAAG,SAAU,CAAC,GAAGC,EAAS,KAAK,CAAC,EAAG,aAAc,CAAC,GAAGC,EAAa,KAAK,CAAC,CAAE,GAExL,MAAe,CACb,IAAMM,EAAWC,GAAwB,CAAC,GAAGA,EAAE,KAAK,CAAC,EAAE,KAAK,EAAE,KAAK,GAAG,EAChEC,EAAW,CAACF,EAAQV,CAAO,EAAGU,EAAQT,CAAQ,EAAGS,EAAQR,CAAQ,EAAGQ,EAAQP,CAAQ,EAAGO,EAAQN,CAAY,CAAC,EAAE,KAAK,GAAG,EACxHS,EAAI,KACR,QAASC,EAAE,EAAEA,EAAEF,EAAS,OAAOE,IAAKD,GAAMA,GAAK,GAAKA,EAAKD,EAAS,WAAWE,CAAC,EAE9E,OAAQD,IAAM,GAAG,SAAS,EAAE,EAAE,SAAS,EAAE,GAAG,CAC9C,CACF,ECfO,SAASE,EAAeC,EAAuM,CACpO,IAAMC,EAAYD,EAAK,IAAY,SAAYA,EAAK,IAAY,SAAS,EAAI,EACvEE,EAAQF,EAAK,OAAO,OAAS,EAC7BG,EAAOH,EAAK,OAAO,MAAQ,EAC3BI,EAAiBJ,EAAK,OAAO,eACnC,MAAO,CACL,QAAS,EACT,MAAOA,EAAK,MACZ,KAAMA,EAAK,KACX,SAAAC,EACA,WAAYI,EAAW,SAAS,EAChC,aAAcA,EAAW,KAAK,EAC9B,QAAS,CAAE,MAAAH,EAAO,KAAAC,EAAM,eAAAC,CAAe,CACzC,CACF,CCGO,IAAME,EAAN,KAAuB,CACpB,QAAoB,CAAC,EACrB,MAAQ,EACR,KAAO,EACP,YAAc,EACL,KACA,IACT,gBAAkB,GAClB,YACA,cAER,YAAYC,EAAmH,CAE/H,GADE,KAAK,KAAOA,GAAM,WAAc,EAAI,GAClCA,GAAM,gBAAgBC,EAAK,KAAK,IAAMD,EAAK,aACtC,OAAOA,GAAM,KAAS,IAAa,KAAK,IAAM,IAAIC,EAAID,EAAK,IAAW,MAC1E,OAAM,IAAI,MAAM,0EAA0E,EAC/F,KAAK,cAAgBA,GAAM,aAC3B,CAEA,SAASE,EAAsB,CAC7B,GAAI,KAAK,QAAQ,KAAKC,GAAKA,EAAE,KAAOD,EAAO,EAAE,EAAG,MAAM,IAAI,MAAM,iCAAiCA,EAAO,EAAE,EAAE,EAC5G,KAAK,QAAQ,KAAKA,CAAM,EACxB,KAAK,YAAY,CACnB,CAEQ,aAAc,CACpB,KAAK,QAAQ,KAAK,CAACE,EAAGC,KAAOD,EAAE,OAAS,IAAMC,EAAE,OAAS,EAAE,CAC7D,CAEA,MAAa,CACX,IAAMC,EAAM,KAAK,aAAa,EAC9B,QAAWH,KAAK,KAAK,QAASA,EAAE,OAAOG,CAAG,CAC5C,CAKA,QAAQC,EAAyB,CAC/B,KAAK,aAAeA,EACpB,IAAIC,EAAQ,EACZ,KAAO,KAAK,YAAc,OAAS,KAAK,MACtC,KAAK,aAAe,KAAK,KACzB,KAAK,KAAK,EACVA,IAEF,OAAOA,CACT,CAEQ,MAAO,CACb,IAAMF,EAAM,KAAK,aAAa,EAC9B,GAAI,KAAK,gBAAiB,CACxB,KAAK,YAAc,CAAC,EACpB,QAAWH,KAAK,KAAK,QAAS,CAC5B,IAAMM,EAAQ,YAAY,IAAI,EAC9BN,EAAE,OAAO,KAAK,KAAMG,CAAG,EACvB,KAAK,YAAYH,EAAE,EAAE,EAAI,YAAY,IAAI,EAAIM,CAC/C,CACJC,EAAS,KAAK,aAAc,CAAE,MAAO,KAAK,MAAO,UAAW,KAAK,WAAY,CAAC,CAC5E,KACE,SAAWP,KAAK,KAAK,QAASA,EAAE,OAAO,KAAK,KAAMG,CAAG,EAEvD,KAAK,QACL,KAAK,MAAQ,KAAK,KAClBI,EAAS,KAAK,QAAS,CAAE,MAAO,KAAK,MAAO,KAAM,KAAK,IAAK,CAAC,CAC/D,CAEQ,cAAoC,CAC1C,MAAO,CACL,MAAO,KAAK,MACZ,KAAM,KAAK,KACX,IAAK,KAAK,IACV,KAAMA,EAAS,KAAK,KAAKA,CAAQ,EACjC,GAAIA,EAAS,GAAG,KAAKA,CAAQ,CAC/B,CACF,CAEA,UAAiB,CACf,IAAMJ,EAAM,KAAK,aAAa,EAC9B,QAAWH,IAAK,CAAC,GAAG,KAAK,OAAO,EAAE,QAAQ,EAAGA,EAAE,WAAWG,CAAG,CAE/D,CAEA,YAAkC,CAChC,MAAO,CAAE,MAAO,KAAK,MAAO,KAAM,KAAK,KAAM,QAAS,KAAK,QAAQ,OAAQ,iBAAkB,EAAG,YAAa,KAAK,YAAa,UAAW,KAAK,WAAY,CAC7J,CAEA,SAAkB,CAAE,OAAO,KAAK,IAAM,CAEtC,eAAeK,EAAO,GAAY,CAAE,KAAK,gBAAkBA,CAAM,CAGjE,UAA4B,CAC5B,IAAMC,EAAOC,EAAe,CAAE,MAAO,KAAK,MAAO,KAAM,KAAK,KAAM,IAAK,KAAK,IAAK,MAAO,KAAK,gBAAgB,CAAE,CAAC,EAChH,OAAAH,EAAS,KAAK,WAAY,CAAE,MAAOE,EAAK,MAAO,KAAMA,EAAK,KAAM,aAAcA,EAAK,aAAc,QAASA,EAAK,OAAQ,CAAC,EACjHA,CACP,CACF,ECjIA,IAAME,EAAN,KAAsB,CAEpB,YAAoBC,EAAW,GAAI,CAAf,cAAAA,CAAgB,CAD5B,IAAuB,CAAC,EAEhC,KAAKC,EAAc,CACjB,IAAMC,EAAID,aAAe,MAAQA,EAAM,IAAI,MAAM,OAAOA,CAAG,CAAC,EAC5D,KAAK,IAAI,KAAK,CAAE,KAAM,KAAK,IAAI,EAAG,QAASC,EAAE,QAAS,MAAOA,EAAE,KAAM,CAAC,EAClE,KAAK,IAAI,OAAS,KAAK,UAAU,KAAK,IAAI,MAAM,CACtD,CACA,MAAwB,CAAE,MAAO,CAAC,GAAG,KAAK,GAAG,CAAG,CAChD,OAAQ,CAAE,KAAK,IAAM,CAAC,CAAG,CAC3B,EAEaC,GAAc,IAAIJ,ECZxB,SAASK,GAAiB,CAC/B,GAAK,KAAa,kBAAmB,OACrC,IAAMC,EAAW,KAAK,OACrB,KAAa,gBAAkBA,EAChC,KAAK,OAAS,IAAMC,EAAU,KAAK,EAClC,KAAa,kBAAoB,EACpC,CCQO,IAAMC,EAAN,KAAc,CAKnB,YAAoBC,EAAsB,CAAtB,UAAAA,EAClB,KAAK,IAAMA,EAAK,IAChB,QAASC,EAAI,EAAGA,EAAID,EAAK,QAASC,IAAK,KAAK,KAAK,KAAK,KAAK,KAAK,CAAC,CACnE,CAPQ,KAAY,CAAC,EACb,MAAQ,EACR,QAAU,EACD,IAKT,MAAU,CAAE,YAAK,QAAS,KAAK,UAAkB,KAAK,KAAK,OAAO,CAAG,CAC7E,SAAyB,CACvB,GAAI,KAAK,KAAK,OAAQ,OAAO,KAAK,KAAK,IAAI,EAC3C,GAAI,OAAK,MAAQ,QAAa,KAAK,OAAS,KAAK,KACjD,OAAO,KAAK,KAAK,CACnB,CACA,QAAQC,EAAc,CACpB,KAAK,KAAK,QAAQA,CAAG,EACrB,KAAK,KAAK,KAAKA,CAAG,CACpB,CACA,OAAmB,CAAE,MAAO,CAAE,KAAM,KAAK,MAAO,KAAM,KAAK,KAAK,OAAQ,MAAO,KAAK,MAAQ,KAAK,KAAK,OAAQ,QAAS,KAAK,QAAS,IAAK,KAAK,GAAI,CAAG,CACtJ,YAAYC,EAAiB,CAC3B,QAASF,EAAI,EAAGA,EAAIE,GACd,OAAK,MAAQ,QAAa,KAAK,OAAS,KAAK,KAD5BF,IAErB,KAAK,KAAK,KAAK,KAAK,KAAK,CAAC,CAE9B,CACF,ECpCAG,EAAW,MAAM,CAAE,GAAI,QAAS,GAAI,GAAI,MAAO,CAAI,CAAC,EACpDA,EAAW,MAAM,CAAE,GAAI,QAAS,GAAI,EAAG,MAAO,GAAI,CAAC,EACnDA,EAAW,MAAM,CAAE,GAAI,OAAQ,GAAI,GAAI,MAAO,EAAI,CAAC,EAGnDA,EAAW,QAAQ,CAAE,GAAI,SAAU,SAAU,CAAE,CAAC,EAChDA,EAAW,QAAQ,CAAE,GAAI,YAAa,SAAU,CAAE,CAAC,EAGnDA,EAAW,QAAQ,CAAE,GAAI,UAAW,KAAM,CAAE,CAAC,EAC7CA,EAAW,QAAQ,CAAE,GAAI,YAAa,KAAM,CAAE,CAAC,EAC/CA,EAAW,QAAQ,CAAE,GAAI,UAAW,KAAM,CAAE,CAAC,EAG7CA,EAAW,QAAQ,CAAE,GAAI,QAAS,YAAa,8BAA+B,CAAC,EAC/EA,EAAW,QAAQ,CAAE,GAAI,UAAW,YAAa,0BAA2B,CAAC,EAG7EA,EAAW,YAAY,CAAE,GAAI,cAAe,QAAS,CAAE,CAAC,EACxDA,EAAW,YAAY,CAAE,GAAI,mBAAoB,QAAS,CAAE,CAAC,EAC7DA,EAAW,YAAY,CAAE,GAAI,uBAAwB,QAAS,CAAE,CAAC,ECC1D,SAASC,GAA6B,CAC3C,IAAMC,EAAY,IAAIC,EAAY,CAChC,QAAS,GACT,OAAQ,KAAO,CAAE,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,MAAO,EAAM,GACtE,MAAOC,GAAK,CAAEA,EAAE,MAAQ,EAAO,CACjC,CAAC,EACKC,EAAa,IAAIF,EAAa,CAClC,QAAS,GACT,OAAQ,KAAO,CAAE,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,MAAO,EAAM,GAC/D,MAAOG,GAAK,CAAEA,EAAE,MAAQ,EAAO,CACjC,CAAC,EACD,MAAO,CAAE,QAAS,CAAC,EAAG,QAAS,CAAC,EAAG,UAAAJ,EAAW,WAAAG,EAAY,MAAO,EAAG,KAAM,EAAG,UAAW,EAAG,WAAY,GAAI,gBAAiB,EAAG,YAAa,EAAG,YAAa,EAAG,aAAc,EAAG,OAAQ,CAAE,EAAG,EAAG,EAAG,EAAG,KAAM,EAAG,WAAY,EAAG,eAAgB,EAAG,cAAe,EAAG,SAAU,EAAG,UAAW,GAAI,OAAQ,EAAG,OAAQ,CAAE,EAAG,SAAU,CAAE,OAAQ,CAAC,CAAE,CAAE,CAClV,CCpCO,IAAME,EAAiB,CAAE,EAAG,EAAG,EAAG,CAAE,EAEpC,SAASC,EAAmBC,EAA0B,CAC3D,MAAO,CACL,GAAI,SAAU,MAAO,KACrB,KAAM,IAAM,CACVF,EAAO,EAAI,EAAGA,EAAO,EAAI,CAC3B,EACA,OAAQ,CAACG,EAAKC,IAA8B,CAE5C,CACF,CACF,CCXO,SAASC,EAAkBC,EAAQ,IAAa,CACrD,IAAMC,EAAiB,CAAC,EACxB,SAASC,EAAOC,EAAkB,CAAEF,EAAKE,EAAE,IAAI,YAAY,CAAC,EAAI,EAAM,CACtE,SAASC,EAAKD,EAAkB,CAAEF,EAAKE,EAAE,IAAI,YAAY,CAAC,EAAI,EAAO,CACrE,MAAO,CACL,GAAI,QAAS,MAAO,KACpB,KAAM,IAAM,CACV,OAAO,iBAAiB,UAAWD,CAAM,EACzC,OAAO,iBAAiB,QAASE,CAAI,CACvC,EACA,OAAQ,CAACC,EAAYC,IAA8B,CACjD,IAAIC,EAAK,EAAGC,EAAK,EAKjB,IAJIP,EAAK,GAAQA,EAAK,WAAYO,GAAM,IACpCP,EAAK,GAAQA,EAAK,aAAcO,GAAM,IACtCP,EAAK,GAAQA,EAAK,aAAcM,GAAM,IACtCN,EAAK,GAAQA,EAAK,cAAeM,GAAM,GACvCA,GAAMC,EAAI,CACZ,IAAMC,EAAM,KAAK,MAAMF,EAAIC,CAAE,GAAK,EAClCD,GAAME,EAAKD,GAAMC,EACjBC,EAAO,GAAKH,EAAKP,EAAQK,EACzBK,EAAO,GAAKF,EAAKR,EAAQK,CAC3B,CACF,EACA,SAAU,IAAM,CACd,OAAO,oBAAoB,UAAWH,CAAM,EAC5C,OAAO,oBAAoB,QAASE,CAAI,CAC1C,CACF,CACF,CC9BO,SAASO,EAAkBC,EAA0B,CAC1D,MAAO,CACL,GAAI,aAAc,MAAO,IACzB,OAAQ,CAACC,EAAIC,IAA6B,CACxCF,EAAM,iBAAmBC,EAEzB,IAAME,EAAW,IACjB,KAAOH,EAAM,iBAAmBG,GAAU,CACxCH,EAAM,iBAAmBG,EACzB,IAAMC,EAAOJ,EAAM,UAAU,QAAQ,EACrC,GAAI,CAACI,EAAM,MACX,IAAMC,EAAQH,EAAI,IAAI,KAAK,EAAI,KAAK,GAAK,EACnCI,EAAO,IAAMJ,EAAI,IAAI,KAAK,EAAI,GAC9BK,EAAQ,GAAKL,EAAI,IAAI,KAAK,EAAI,GACpCE,EAAK,GAAKJ,EAAM,cAChBI,EAAK,EAAI,KAAK,IAAIC,CAAK,EAAIC,EAC3BF,EAAK,EAAI,KAAK,IAAIC,CAAK,EAAIC,EAC3BF,EAAK,GAAK,CAAC,KAAK,IAAIC,CAAK,EAAIE,EAC7BH,EAAK,GAAK,CAAC,KAAK,IAAIC,CAAK,EAAIE,EAC7BH,EAAK,GAAK,EACVA,EAAK,MAAQ,GACbJ,EAAM,QAAQ,KAAKI,CAAa,CAClC,CAEA,QAAWI,KAAKR,EAAM,QAAaQ,EAAE,QAASA,EAAE,GAAKA,EAAE,GAAKP,EAAIO,EAAE,GAAKA,EAAE,GAAKP,EAChF,CACF,CACF,CC1BO,SAASQ,EAAmBC,EAA0B,CAC3D,MAAO,CACL,GAAI,UAAW,MAAO,EACtB,OAAQ,CAACC,EAAIC,IAA8B,CACzCF,EAAM,aAAeC,EACrB,IAAME,EAAe,GACrB,KAAOH,EAAM,aAAeG,GAAc,CACxCH,EAAM,aAAeG,EACrB,IAAMC,EAAOJ,EAAM,WAAW,QAAQ,EACtC,GAAI,CAACI,EAAM,MAEX,IAAMC,EADML,EAAM,aACG,IAAO,KAAK,GAAK,EAAI,IACpCM,EAAQ,IACdF,EAAK,GAAKJ,EAAM,eAChBI,EAAK,EAAIG,EAAO,EAAGH,EAAK,EAAIG,EAAO,EACnCH,EAAK,GAAK,KAAK,IAAIC,CAAK,EAAIC,EAAOF,EAAK,GAAK,KAAK,IAAIC,CAAK,EAAIC,EAC/DF,EAAK,MAAQ,GACbJ,EAAM,QAAQ,KAAKI,CAAc,CACnC,CAEA,QAAWI,KAAKR,EAAM,QAAaQ,EAAE,QAASA,EAAE,GAAKA,EAAE,GAAKP,EAAIO,EAAE,GAAKA,EAAE,GAAKP,EAChF,CACF,CACF,CCxBO,SAASQ,GAAsBC,EAA0B,CAC9D,MAAO,CACL,GAAI,YAAa,MAAO,GACxB,OAAQ,CAACC,EAAKC,IAA8B,CAC1C,QAAWC,KAAKH,EAAM,QAAS,GAAIG,EAAE,OACnC,QAAWC,KAAKJ,EAAM,QAAS,GAAII,EAAE,MAAO,CAC1C,IAAMC,EAAKD,EAAE,EAAID,EAAE,EAASG,EAAKF,EAAE,EAAID,EAAE,EACzC,GAAIE,EAAGA,EAAKC,EAAGA,EAAK,IAAO,CACzBF,EAAE,MAAQ,GAAOD,EAAE,MAAQ,GAAOH,EAAM,QAASA,EAAM,YAAa,KACtE,CACF,EAGF,GAAIA,EAAM,MAAQ,IAAM,EAAG,CACzB,QAASO,EAAIP,EAAM,QAAQ,OAAS,EAAGO,GAAK,EAAGA,IAAK,CAClD,IAAMH,EAAIJ,EAAM,QAAQO,CAAC,EACpBH,EAAE,QAASJ,EAAM,QAAQ,OAAOO,EAAE,CAAC,EAAGP,EAAM,UAAU,QAAQI,CAAC,EACtE,CACA,QAASG,EAAIP,EAAM,QAAQ,OAAS,EAAGO,GAAK,EAAGA,IAAK,CAClD,IAAMJ,EAAIH,EAAM,QAAQO,CAAC,GACnB,CAACJ,EAAE,OAAS,KAAK,IAAIA,EAAE,CAAC,EAAI,KAAO,KAAK,IAAIA,EAAE,CAAC,EAAI,OAAOH,EAAM,QAAQ,OAAOO,EAAE,CAAC,EAAGP,EAAM,WAAW,QAAQG,CAAC,EACvH,CACF,CACF,CACF,CACF,CCvBO,SAASK,GAAmBC,EAA0B,CAC3D,IAAIC,EAAmC,KACnCC,EAAuC,KAC3C,SAASC,GAAO,CACdF,EAAS,SAAS,eAAe,MAAM,EAClCA,IAAgBC,EAAMD,EAAO,WAAW,IAAI,EACnD,CACA,SAASG,GAAQ,CACX,CAACH,GAAU,CAACC,IAChBA,EAAI,UAAY,OAChBA,EAAI,SAAS,EAAE,EAAED,EAAO,MAAMA,EAAO,MAAM,EAC7C,CACA,SAASI,GAAkB,CACzB,GAAI,CAACJ,GAAU,CAACC,EAAK,OACrBA,EAAI,KAAK,EACT,IAAMI,EAAQL,EAAO,OAAO,EAAE,kBACxBM,EAAQN,EAAO,QAAQ,EAAE,kBAC/BC,EAAI,UAAUI,EAAOC,CAAK,EAE1B,IAAMC,EAAIR,EAAM,OAAO,MAAQ,EAC/BE,EAAI,MAAMM,EAAGA,CAAC,EAEdN,EAAI,UAAU,CAACF,EAAM,OAAO,GAAKA,EAAM,OAAO,QAAQ,GAAGQ,EAAG,CAACR,EAAM,OAAO,GAAKA,EAAM,OAAO,QAAQ,GAAGQ,CAAC,CAC1G,CACA,SAASC,GAAU,CAAMP,GAAKA,EAAI,QAAQ,CAAG,CAC7C,MAAO,CACL,GAAI,SAAU,MAAO,IACrB,KAAM,IAAM,CAAM,OAAO,OAAW,KAAaC,EAAK,CAAG,EACzD,OAAQ,IAAM,CACZ,GAAI,CAACF,GAAU,CAACC,EAAK,OACrBE,EAAM,EACNC,EAAgB,EAEhB,IAAMK,EAAeV,EAAM,UAAU,QAAQ,OAASA,EAAM,SAAU,OAAS,CAC7E,CAAE,MAAO,GAAK,QAASA,EAAM,OAAO,EAAI,GAAK,QAASA,EAAM,OAAO,EAAI,EAAI,EAC3E,CAAE,MAAO,GAAK,QAASA,EAAM,OAAO,EAAI,GAAK,QAASA,EAAM,OAAO,EAAI,EAAI,CAC7E,EACA,QAAWW,KAAKD,EAAc,CAC5B,IAAME,EAAQD,EAAU,QAClBE,EAAQF,EAAU,QAClBG,EAASH,EAAU,QAAUA,EAAE,MAAQ,GAAM,OAAS,QAC5DT,EAAI,UAAYY,EAChB,IAAMC,EAAQJ,EAAU,WAAaA,EAAE,MAAQ,GAAM,KAAO,MACtDK,EAAQL,EAAU,OAASA,EAAE,MAAQ,GAAM,IAAM,IACjDM,EAAS,KAAK,OAAOL,EAAOG,EAAK,GAAGC,CAAI,EAAEA,EAC1CE,EAAS,KAAK,OAAOL,EAAOE,EAAK,GAAGC,CAAI,EAAEA,EAChD,QAASG,EAAIF,EAAQE,EAAIP,EAAOG,EAAK,EAAGI,GAAKH,EAC3C,QAASI,EAAIF,EAAQE,EAAIP,EAAOE,EAAK,EAAGK,GAAKJ,EAAM,CACjD,IAAMK,EAAKF,EAAIP,EACTU,EAAKF,EAAIP,EACfX,EAAI,SAASmB,EAAIC,EAAI,EAAE,CAAC,CAC1B,CAEJ,CAEApB,EAAI,YAAc,OAClBA,EAAI,UAAU,EAAGA,EAAI,IAAIqB,EAAO,EAAGA,EAAO,EAAG,GAAI,EAAG,KAAK,GAAG,CAAC,EAAGrB,EAAI,OAAO,EAE3EA,EAAI,UAAY,OAChB,QAAWsB,KAAKxB,EAAM,QAAawB,EAAE,OAAOtB,EAAI,SAASsB,EAAE,EAAE,EAAGA,EAAE,EAAE,EAAG,EAAE,CAAC,EAE1EtB,EAAI,UAAY,OAChB,QAAWuB,KAAKzB,EAAM,QAAayB,EAAE,QAASvB,EAAI,UAAU,EAAGA,EAAI,IAAIuB,EAAE,EAAGA,EAAE,EAAG,EAAG,EAAG,KAAK,GAAG,CAAC,EAAGvB,EAAI,KAAK,GAC5GO,EAAQ,CACV,CACF,CACF,CClEO,SAASiB,GAAmBC,EAAkBC,EAAkN,CACrQ,IAAMC,EAAYD,GAAM,WAAa,GAC/BE,EAAWF,GAAM,UAAY,EAC7BG,EAAYH,GAAM,eAAiB,EACnCI,EAAWJ,GAAM,UAAY,EAC7BK,EAAUL,GAAM,SAAW,IAE3BM,EAAcN,GAAM,aAAe,EACnCO,EAAOP,GAAM,OAEf,OAAO,OAAW,MACnB,OAAe,YAAc,SAASQ,EAAW,GAAKC,EAAM,GAAIC,EAAO,GAAI,CAC1EX,EAAM,OAAO,cAAgBS,EAC7BT,EAAM,OAAO,eAAiBS,EAC9BT,EAAM,OAAO,SAAWU,EACxBV,EAAM,OAAO,UAAYW,CAC3B,EACC,OAAe,aAAe,SAASC,EAAI,EAAG,CAAEZ,EAAM,OAAO,WAAa,KAAK,IAAI,GAAK,KAAK,IAAI,EAAGY,CAAC,CAAC,CAAG,GAG5G,IAAIC,EAASC,EAAO,EAChBC,EAASD,EAAO,EACpB,MAAO,CACL,GAAI,SAAU,MAAO,KACrB,OAAQ,CAACE,EAAYC,IAA8B,CACjD,IAAMC,EAAKlB,EAAM,OAAO,EAClBmB,EAAKnB,EAAM,OAAO,EAEpBoB,EAAKN,EAAO,EACZO,EAAKP,EAAO,EAEhB,GAAIT,EAAW,GAAKW,EAAK,EAAG,CAC1B,IAAMM,GAAMR,EAAO,EAAID,GAAUG,EAC3BO,GAAMT,EAAO,EAAIC,GAAUC,EAC7BQ,EAAKF,EAAKjB,EACVoB,EAAKF,EAAKlB,EACRqB,EAAM,KAAK,MAAMF,EAAIC,CAAE,EAC7B,GAAIC,EAAMpB,EAAS,CAAE,IAAMqB,EAAIrB,GAAWoB,GAAO,GAAIF,GAAMG,EAAGF,GAAME,CAAG,CACvEP,GAAMI,EAAIH,GAAMI,CAClB,CAEI,KAAK,IAAIL,EAAKF,CAAE,EAAIf,IAAUiB,EAAKF,GACnC,KAAK,IAAIG,EAAKF,CAAE,EAAIhB,IAAUkB,EAAKF,GAEvC,IAAMS,EAAO,EAAI,KAAK,IAAI,CAAC1B,EAAYc,CAAE,EACrCa,EAAKX,GAAME,EAAKF,GAAMU,EACtBE,EAAKX,GAAME,EAAKF,GAAMS,EAE1B,GAAIpB,EACFqB,EAAK,KAAK,IAAIrB,EAAK,KAAM,KAAK,IAAIA,EAAK,KAAMqB,CAAE,CAAC,EAChDC,EAAK,KAAK,IAAItB,EAAK,KAAM,KAAK,IAAIA,EAAK,KAAMsB,CAAE,CAAC,UACvCvB,EAAc,EAAG,CAC1B,IAAMwB,EAAQF,EAAGA,EAAKC,EAAGA,EACnBE,EAAIzB,EACV,GAAIwB,EAAQC,EAAEA,EAAG,CAAE,IAAMC,EAAI,KAAK,KAAKF,CAAK,EAAGF,EAAKA,EAAKI,EAAID,EAAGF,EAAKA,EAAKG,EAAID,CAAG,CACnF,CACAhC,EAAM,OAAO,EAAI6B,EACjB7B,EAAM,OAAO,EAAI8B,EAEjB,IAAMI,GAAW,EAAI,KAAK,IAAI,CAAC9B,EAAYY,CAAE,EAG7C,GAFAhB,EAAM,OAAO,OAASA,EAAM,OAAO,WAAaA,EAAM,OAAO,MAAQkC,GAEjElC,EAAM,OAAO,eAAiB,EAAG,CACnCA,EAAM,OAAO,gBAAkBgB,EAC/B,IAAMmB,EAAInC,EAAM,OAAO,cAAgBA,EAAM,OAAO,eAE9CoC,EADW,KAAK,IAAI,EAAGpC,EAAM,OAAO,cAAc,EAAIA,EAAM,OAAO,cAEnEqC,EAAIrC,EAAM,OAAO,UAEvBA,EAAM,OAAO,QAAU,KAAK,IAAImC,EAAIE,EAAI,KAAK,EAAI,GAAM,KAAK,IAAIF,EAAIE,EAAI,IAAI,EAAI,IAAOrC,EAAM,OAAO,SAAWoC,EAC/GpC,EAAM,OAAO,QAAU,KAAK,IAAImC,EAAIE,EAAI,KAAK,EAAI,GAAM,KAAK,IAAIF,EAAIE,EAAI,IAAI,EAAI,IAAOrC,EAAM,OAAO,SAAWoC,CACjH,MACEpC,EAAM,OAAO,OAAS,EAAGA,EAAM,OAAO,OAAS,EAErDa,EAASC,EAAO,EAChBC,EAASD,EAAO,CACd,CACF,CACF,CC1EO,SAASwB,GAAiBC,EAA0B,CACzD,MAAO,CACL,GAAI,OAAQ,MAAO,IACnB,OAAQ,CAACC,EAAKC,IAA8B,CAC1C,GAAIF,EAAM,WAAaA,EAAM,WAAY,CACvC,IAAMG,EAAOH,EAAM,KACnBA,EAAM,MAAQ,EACdA,EAAM,UAAY,EAElBA,EAAM,WAAa,KAAK,IAAI,IAAK,KAAK,KAAKA,EAAM,WAAa,IAAI,CAAC,EACnEI,EAAS,KAAK,YAAa,CAAE,KAAMJ,EAAM,KAAM,SAAUG,EAAM,OAAQH,EAAM,UAAW,CAAC,CAC3F,CACF,CACF,CACF,CCdO,SAASK,GAAqBC,EAAkBC,EAAwC,CAC7F,IAAIC,EAAmCD,GAAQ,OAASA,EAAS,CAC/D,CAAE,MAAO,GAAK,QAAS,GAAK,MAAO,OAAQ,SAAU,KAAM,KAAM,GAAI,EACrE,CAAE,MAAO,GAAK,QAAS,GAAK,MAAO,OAAQ,SAAU,KAAM,KAAM,EAAG,CACtE,EACA,GAAI,OAAO,OAAW,IAAa,CACjC,IAAME,EAAYC,GACTA,GAAK,OAAOA,EAAE,OAAU,UAAY,SAASA,EAAE,KAAK,GAAKA,EAAE,MAAQ,GAAKA,EAAE,OAAS,EAEtFC,EAAYD,IAAiC,CACjD,MAAO,KAAK,IAAI,IAAM,KAAK,IAAI,EAAG,CAACA,EAAE,KAAK,CAAC,EAC3C,QAAS,OAAOA,EAAE,SAAY,SAAW,KAAK,IAAI,EAAG,KAAK,IAAI,EAAGA,EAAE,OAAO,CAAC,EAAI,OAC/E,MAAO,OAAOA,EAAE,OAAU,SAAWA,EAAE,MAAQ,OAC/C,SAAU,OAAOA,EAAE,UAAa,UAAYA,EAAE,SAAW,EAAI,KAAK,IAAI,KAAMA,EAAE,QAAQ,EAAI,OAC1F,KAAM,OAAOA,EAAE,MAAS,UAAYA,EAAE,KAAO,EAAI,KAAK,IAAI,KAAMA,EAAE,IAAI,EAAI,MAC5E,GACME,EAAU,IAAM,CACpB,GAAI,CACF,IAAMC,EAAU,mBAAmB,KAAK,UAAUL,CAAS,CAAC,EAE5D,GAAI,OAAO,QAAY,IAAa,CAClC,IAAMM,EAAM,IAAI,IAAI,OAAO,SAAS,IAAI,EACtCA,EAAI,aAAa,IAAI,YAAaD,CAAO,EACzC,QAAQ,aAAa,KAAM,GAAIC,EAAI,SAAS,CAAC,CACjD,CAEA,OAAO,aAAa,QAAQ,iBAAkB,KAAK,UAAUN,CAAS,CAAC,CACzE,MAAQ,CAAC,CACX,EACC,OAAe,kBAAqBO,GAAgC,CAC/D,MAAM,QAAQA,CAAI,GAAKA,EAAK,MAAMN,CAAQ,IAAKD,EAAYO,EAAK,IAAIJ,CAAQ,EAAGC,EAAQ,EAC7F,EACC,OAAe,iBAAoBI,GAC9BP,EAASO,CAAG,GAAKR,EAAU,KAAKG,EAASK,CAAG,CAAC,EAAGJ,EAAQ,EAAU,IAAe,GAEtF,OAAe,oBAAuBK,GACjC,OAAOA,GAAU,UAAYA,GAAQ,GAAKA,EAAQT,EAAU,QAAUA,EAAU,OAAOS,EAAM,CAAC,EAAGL,EAAQ,EAAU,IAAe,GAEvI,OAAe,oBAAsB,CAACK,EAAeC,IAAwC,CAC5F,GAAID,EAAQ,GAAKA,GAAST,EAAU,OAAQ,MAAO,GACnD,IAAMW,EAAS,CAAE,GAAGX,EAAUS,CAAK,EAAG,GAAGC,CAAM,EAC/C,OAAIT,EAASU,CAAM,GAAKX,EAAUS,CAAK,EAAIN,EAASQ,CAAM,EAAGP,EAAQ,EAAU,IACxE,EACT,EACC,OAAe,mBAAqB,IAAMJ,EAAU,IAAIY,IAAM,CAAE,GAAGA,CAAE,EAAE,EACvE,OAAe,wBAA0B,IAAM,mBAAmB,KAAK,UAAUZ,CAAS,CAAC,EAC3F,OAAe,gBAAkBI,EAElC,GAAI,CAEF,IAAMS,EADM,IAAI,IAAI,OAAO,SAAS,IAAI,EACxB,aAAa,IAAI,WAAW,EAC5C,GAAIA,EAAK,CACP,IAAMC,EAAS,KAAK,MAAM,mBAAmBD,CAAG,CAAC,EAC7C,MAAM,QAAQC,CAAM,GAAKA,EAAO,MAAMb,CAAQ,IAChDD,EAAYc,EAAO,IAAIX,CAAQ,EAGnC,KAAO,CAEL,IAAMY,EAAS,OAAO,aAAa,QAAQ,gBAAgB,EAC3D,GAAIA,EAAQ,CACV,IAAMD,EAAS,KAAK,MAAMC,CAAM,EAC5B,MAAM,QAAQD,CAAM,GAAKA,EAAO,MAAMb,CAAQ,IAAGD,EAAYc,EAAO,IAAIX,CAAQ,EACtF,CACF,CACF,OAASa,EAAG,CACV,QAAQ,KAAK,6CAA8CA,CAAC,CAC9D,CACF,CAEA,OAAKlB,EAAM,WAAUA,EAAM,SAAW,CAAE,OAAQ,CAAC,CAAE,GAC5C,CACL,GAAI,WAAY,MAAO,GACvB,OAAQ,CAACmB,EAAaC,IAA8B,CAClDpB,EAAM,SAAU,OAASE,EAAU,IAAImB,IAAO,CAAE,MAAOA,EAAG,MAAO,QAASrB,EAAM,OAAO,EAAIqB,EAAG,MAAO,QAASrB,EAAM,OAAO,EAAIqB,EAAG,MAAO,MAAOA,EAAG,MAAO,SAAUA,EAAG,SAAU,KAAMA,EAAG,IAAK,EAAE,CACnM,CACF,CACF,CCxEAC,EAAe,EAGf,IAAMC,GAAM,IAAI,IAAI,OAAO,SAAS,IAAI,EAClCC,EAAOD,GAAI,aAAa,IAAI,MAAM,GAAK,WACvCE,GAAYF,GAAI,aAAa,IAAI,WAAW,IAAM,IAElDG,EAAYC,EAAgB,EAC5BC,EAAe,IAAIC,EAAiB,CAAE,KAAAL,EAAM,UAAW,EAAE,GAAI,cAAe,KAAO,CACvF,MAAOE,EAAU,MACjB,KAAMA,EAAU,KAChB,eAAgBA,EAAU,UAAU,QAAQ,IAAII,GAAK,CACnD,IAAMC,EAAMD,EACZ,MAAO,CAAE,MAAOC,EAAI,MAAO,MAAOA,EAAI,MAAO,SAAUA,EAAI,SAAU,KAAMA,EAAI,IAAK,CACtF,CAAC,GAAK,CAAC,CACT,EAAG,CAAC,EACJH,EAAa,SAASI,EAAkB,CAAC,EACzCJ,EAAa,SAASK,GAAmBP,CAAS,CAAC,EACnDE,EAAa,SAASM,EAAmBR,CAAS,CAAC,EACnDE,EAAa,SAASO,GAAiBT,CAAS,CAAC,EACjDE,EAAa,SAASQ,EAAkBV,CAAS,CAAC,EAClDE,EAAa,SAASS,EAAmBX,CAAS,CAAC,EACnDE,EAAa,SAASU,GAAsBZ,CAAS,CAAC,EACtDE,EAAa,SAASW,GAAmBb,CAAS,CAAC,EAEnDE,EAAa,SAASY,GAAqBd,CAAS,CAAC,EAGrD,IAAMe,GAAU,SAAS,eAAe,SAAS,EAC7CC,EAAW,GACXC,EAAS,GACTC,EAAW,GACf,OAAO,iBAAiB,UAAW,GAAK,CAClC,EAAE,MAAQ,MAAOF,EAAW,CAACA,EAAUd,EAAa,eAAec,CAAQ,GAC3E,EAAE,MAAQ,KAAO,QAAQ,IAAI,WAAYd,EAAa,SAAS,CAAC,EAChE,EAAE,MAAQ,MAAOe,EAAS,CAACA,GAC3B,EAAE,MAAQ,MAAOC,EAAW,GAClC,CAAC,EAEDhB,EAAa,KAAK,EAElB,IAAIiB,GAAO,YAAY,IAAI,EAC3B,SAASC,GAAKC,EAAa,CACzB,IAAMC,GAAWD,EAAMF,IAAQ,IAC/BA,GAAOE,EACFJ,EACIC,IAAYhB,EAAa,QAAQA,EAAa,QAAQ,CAAC,EAAGgB,EAAW,IADjEhB,EAAa,QAAQoB,CAAO,EAEzC,IAAMC,EAAUrB,EAAa,WAAW,EACxCa,GAAQ,YAAc,QAAQjB,CAAI;AAAA,QAAWyB,EAAQ,KAAK;AAAA,OAAUA,EAAQ,KAAK,QAAQ,CAAC,CAAC;AAAA,SAAavB,EAAU,KAAK,SAASA,EAAU,IAAI,IAAIiB,EAAS,YAAc,EAAE;AAAA,gBAAmBjB,EAAU,UAAU,MAAM,EAAE,KAAK,SAASA,EAAU,UAAU,MAAM,EAAE,IAAI;AAAA,gBAAmBA,EAAU,WAAW,MAAM,EAAE,KAAK,SAASA,EAAU,WAAW,MAAM,EAAE,IAAI,IAAMgB,GAAYO,EAAQ,UAAY;AAAA,EAAO,OAAO,QAAQA,EAAQ,SAAS,EAAE,IAAI,CAAC,CAACC,EAAEC,CAAC,IAAI,GAAGD,CAAC,IAAIC,EAAE,QAAQ,CAAC,CAAC,IAAI,EAAE,KAAK;AAAA,CAAI,EAAI,IAC1e,sBAAsBL,EAAI,CAC5B,CACA,sBAAsBA,EAAI,EAE1B,QAAQ,IAAI,6CAA8CtB,EAAMC,GAAY,WAAa,EAAE",
  "names": ["RNG", "seed", "h", "i", "min", "max", "span", "arr", "state", "globalRng", "EventBus", "event", "handler", "set", "payload", "h", "eventBus", "enemies", "powerups", "upgrades", "waveMods", "bossPatterns", "ensureUnique", "map", "def", "kind", "Registries", "collect", "m", "combined", "h", "i", "createSnapshot", "meta", "rngState", "kills", "wave", "parallaxLayers", "Registries", "GameOrchestrator", "opts", "RNG", "system", "s", "a", "b", "ctx", "elapsed", "steps", "start", "eventBus", "flag", "snap", "createSnapshot", "ErrorRingBuffer", "capacity", "err", "e", "errorBuffer", "installRngShim", "original", "globalRng", "Pool", "opts", "i", "obj", "n", "Registries", "createGameState", "enemyPool", "Pool", "e", "bulletPool", "b", "player", "createPlayerSystem", "state", "_dt", "_ctx", "createInputSystem", "speed", "keys", "onDown", "e", "onUp", "dt", "_ctx", "vx", "vy", "len", "player", "createEnemySystem", "state", "dt", "ctx", "interval", "slot", "angle", "dist", "speed", "e", "createBulletSystem", "state", "dt", "_ctx", "fireInterval", "slot", "angle", "speed", "player", "b", "createCollisionSystem", "state", "_dt", "_ctx", "b", "e", "dx", "dy", "i", "createRenderSystem", "state", "canvas", "ctx", "init", "clear", "translateOrigin", "baseX", "baseY", "z", "restore", "renderLayers", "l", "parX", "parY", "color", "size", "step", "startX", "startY", "x", "y", "sx", "sy", "player", "b", "e", "createCameraSystem", "state", "opts", "stiffness", "deadzone", "zoomStiff", "leadTime", "maxLead", "worldRadius", "rect", "duration", "amp", "freq", "z", "prevPx", "player", "prevPy", "dt", "_ctx", "cx", "cy", "tx", "ty", "vx", "vy", "lx", "ly", "mag", "s", "lerp", "nx", "ny", "dist2", "r", "d", "zoomLerp", "t", "damp", "f", "createWaveSystem", "state", "_dt", "_ctx", "prev", "eventBus", "createParallaxSystem", "state", "layers", "layerDefs", "validate", "d", "sanitize", "persist", "encoded", "url", "defs", "def", "index", "patch", "merged", "l", "raw", "parsed", "stored", "e", "_dt", "_ctx", "ld", "installRngShim", "url", "seed", "autoPause", "gameState", "createGameState", "orchestrator", "GameOrchestrator", "l", "ext", "createInputSystem", "createCameraSystem", "createPlayerSystem", "createWaveSystem", "createEnemySystem", "createBulletSystem", "createCollisionSystem", "createRenderSystem", "createParallaxSystem", "overlay", "profiler", "paused", "stepOnce", "last", "loop", "now", "elapsed", "metrics", "k", "v"]
}
